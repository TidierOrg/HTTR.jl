{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#httrjl","title":"HTTR.jl","text":"<p><code>HTTR.jl</code> is a 100% Julia implementation of the R httr2 package.</p> <p>The main purpose of <code>HTTR.jl</code> is to bridge the gap between the web and data analysis in Julia, offering a flexible and efficient interface for making HTTP requests while adhering to web standards. It leverages packages like <code>EzXML.jl</code>, <code>HTTP.jl</code>, <code>JLD2.jl</code>, <code>JSON3.jl</code>, and <code>URIs.jl</code> to create and handle requests and manage various types of web data.</p> <p>HTTR.jl currently implement the following functions and types from httr:</p> Category Function/Type Create and Modify Requests <code>request()</code>, <code>Request</code>, <code>req_body_raw()</code>, <code>req_body_file()</code>, <code>req_body_json()</code>, <code>req_headers()</code>,<code>req_method()</code>, <code>req_progress()</code>,<code>req_timeout()</code>, <code>req_url()</code>, <code>req_user_agent()</code> Debugging and Testing Requests <code>last_response()</code>, <code>last_request()</code>, <code>req_verbose()</code>, <code>with_verbosity()</code> Requests Authentication <code>req_auth_basic()</code>, <code>req_auth_bearer_token()</code> Perform a Request <code>req_perform()</code>, <code>req_retry()</code> Perform Multiple Requests (No functions included) Handle the Response <code>resp_body_raw()</code>, <code>resp_has_body()</code>, <code>resp_body_string()</code>, <code>resp_body_json()</code>,<code>resp_body_html()</code>, <code>resp_body_xml()</code>, <code>resp_check_content_type()</code>, <code>resp_content_type()</code>, <code>resp_encoding()</code>, <code>resp_date()</code>, <code>resp_headers()</code>, <code>resp_header()</code>, <code>resp_header_exists()</code>, <code>resp_link_url()</code>, <code>resp_raw()</code>, <code>resp_retry_after()</code>, <code>resp_status()</code>, <code>resp_status_desc()</code>, <code>resp_is_error()</code>,<code>resp_check_status()</code>, <code>resp_url()</code>, <code>resp_url_path()</code>, <code>resp_url_query()</code>, <code>resp_url_queries()</code> Miscellaneous Helpers <code>curl_help()</code>, <code>secret_make_key()</code>, <code>secret_has_key()</code>, <code>url_parse()</code>, <code>url_build()</code> OAuth <code>oauth_cache_path()</code>, <code>OAuthClient</code>, <code>oauth_client()</code>, <code>oauth_redirect_uri()</code>, <code>OAuthToken</code>, <code>oauth_token()</code>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>HTTR.HTTR</code></li> <li><code>HTTR.OAuthClient</code></li> <li><code>HTTR.OAuthToken</code></li> <li><code>HTTR.Obfuscated</code></li> <li><code>HTTR.Request</code></li> <li><code>HTTR.curl_help</code></li> <li><code>HTTR.curl_translate</code></li> <li><code>HTTR.last_request</code></li> <li><code>HTTR.last_response</code></li> <li><code>HTTR.local_mocked_responses</code></li> <li><code>HTTR.oauth_cache_path</code></li> <li><code>HTTR.oauth_client</code></li> <li><code>HTTR.oauth_client_req_auth</code></li> <li><code>HTTR.oauth_client_req_auth_body</code></li> <li><code>HTTR.oauth_client_req_auth_header</code></li> <li><code>HTTR.oauth_client_req_auth_jwt_sig</code></li> <li><code>HTTR.oauth_flow_auth_code</code></li> <li><code>HTTR.oauth_flow_bearer_jwt</code></li> <li><code>HTTR.oauth_flow_client_credentials</code></li> <li><code>HTTR.oauth_flow_device</code></li> <li><code>HTTR.oauth_flow_password</code></li> <li><code>HTTR.oauth_flow_refresh</code></li> <li><code>HTTR.oauth_redirect_uri</code></li> <li><code>HTTR.oauth_token</code></li> <li><code>HTTR.obfuscate</code></li> <li><code>HTTR.obfuscated</code></li> <li><code>HTTR.req_auth_basic</code></li> <li><code>HTTR.req_auth_bearer_token</code></li> <li><code>HTTR.req_body_file</code></li> <li><code>HTTR.req_body_form</code></li> <li><code>HTTR.req_body_json</code></li> <li><code>HTTR.req_body_json_modify</code></li> <li><code>HTTR.req_body_multipart</code></li> <li><code>HTTR.req_body_raw</code></li> <li><code>HTTR.req_cache</code></li> <li><code>HTTR.req_cookie_preserve</code></li> <li><code>HTTR.req_dry_run</code></li> <li><code>HTTR.req_error</code></li> <li><code>HTTR.req_headers</code></li> <li><code>HTTR.req_method</code></li> <li><code>HTTR.req_oauth_auth_code</code></li> <li><code>HTTR.req_oauth_bearer_jwt</code></li> <li><code>HTTR.req_oauth_client_credentials</code></li> <li><code>HTTR.req_oauth_device</code></li> <li><code>HTTR.req_oauth_password</code></li> <li><code>HTTR.req_oauth_refresh</code></li> <li><code>HTTR.req_options</code></li> <li><code>HTTR.req_perform</code></li> <li><code>HTTR.req_perform_stream</code></li> <li><code>HTTR.req_progress</code></li> <li><code>HTTR.req_proxy</code></li> <li><code>HTTR.req_retry</code></li> <li><code>HTTR.req_template</code></li> <li><code>HTTR.req_throttle</code></li> <li><code>HTTR.req_timeout</code></li> <li><code>HTTR.req_url</code></li> <li><code>HTTR.req_url_path</code></li> <li><code>HTTR.req_url_path_append</code></li> <li><code>HTTR.req_url_query</code></li> <li><code>HTTR.req_user_agent</code></li> <li><code>HTTR.req_verbose</code></li> <li><code>HTTR.request</code></li> <li><code>HTTR.resp_body_html</code></li> <li><code>HTTR.resp_body_json</code></li> <li><code>HTTR.resp_body_raw</code></li> <li><code>HTTR.resp_body_string</code></li> <li><code>HTTR.resp_body_xml</code></li> <li><code>HTTR.resp_check_content_type</code></li> <li><code>HTTR.resp_check_status</code></li> <li><code>HTTR.resp_content_type</code></li> <li><code>HTTR.resp_date</code></li> <li><code>HTTR.resp_encoding</code></li> <li><code>HTTR.resp_has_body</code></li> <li><code>HTTR.resp_header</code></li> <li><code>HTTR.resp_header_exists</code></li> <li><code>HTTR.resp_headers</code></li> <li><code>HTTR.resp_is_error</code></li> <li><code>HTTR.resp_link_url</code></li> <li><code>HTTR.resp_raw</code></li> <li><code>HTTR.resp_retry_after</code></li> <li><code>HTTR.resp_status</code></li> <li><code>HTTR.resp_status_desc</code></li> <li><code>HTTR.resp_url</code></li> <li><code>HTTR.resp_url_path</code></li> <li><code>HTTR.resp_url_queries</code></li> <li><code>HTTR.resp_url_query</code></li> <li><code>HTTR.secret_decrypt</code></li> <li><code>HTTR.secret_decrypt_file</code></li> <li><code>HTTR.secret_encrypt</code></li> <li><code>HTTR.secret_encrypt_file</code></li> <li><code>HTTR.secret_has_key</code></li> <li><code>HTTR.secret_make_key</code></li> <li><code>HTTR.secret_read_jld</code></li> <li><code>HTTR.secret_write_jld</code></li> <li><code>HTTR.unobfuscate</code></li> <li><code>HTTR.url_build</code></li> <li><code>HTTR.url_parse</code></li> <li><code>HTTR.with_mocked_responses</code></li> <li><code>HTTR.with_verbosity</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>HTTR.HTTR</code> \u2014 Module.</p> <pre><code>HTTR\n</code></pre> <p>Julia port of httr2 </p> <p>source</p> <p># <code>HTTR.OAuthClient</code> \u2014 Type.</p> <p>source</p> <p># <code>HTTR.OAuthToken</code> \u2014 Type.</p> <p>source</p> <p># <code>HTTR.Request</code> \u2014 Type.</p> <pre><code>HTTR.Request\n</code></pre> <p>Request object for HTTR functions.</p> <p>Arguments</p> <ul> <li><code>base_url::AbstractString</code>: The base URL of the request.</li> <li><code>method::AbstractString</code>: The HTTP method of the request.</li> <li><code>body::Any</code>: The body of the request.</li> <li><code>headers::AbstractVector</code>: The headers of the request.</li> <li><code>verbosity::Int</code>: The verbosity of the request.</li> <li><code>retries::Int</code>: The number of retries of the request.</li> <li><code>retry::Bool</code>: Whether to retry the request.</li> <li><code>timeout::Int</code>: The timeout of the request.</li> <li><code>progress::Bool</code>: Whether to show the progress of the request.</li> </ul> <p>source</p> <p># <code>HTTR.curl_help</code> \u2014 Method.</p> <pre><code>HTTR.curl_help()::String\n</code></pre> <p>This function prints out useful information about the curl command line tool.</p> <p>source</p> <p># <code>HTTR.last_request</code> \u2014 Method.</p> <pre><code>HTTR.last_request()::Union{Nothing,HTTR.Request}\n</code></pre> <p>Returns the last request object.</p> <p>Returns</p> <ul> <li><code>Union{Nothing,HTTR.Request}</code>: The last request object.</li> </ul> <p>source</p> <p># <code>HTTR.last_response</code> \u2014 Method.</p> <pre><code>HTTR.last_response()::Union{Nothing,HTTP.Messages.Response}\n</code></pre> <p>Returns the last response object.</p> <p>Returns</p> <ul> <li><code>Union{Nothing,HTTP.Messages.Response}</code>: The last response object.</li> </ul> <p>source</p> <p># <code>HTTR.oauth_cache_path</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_client</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_redirect_uri</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_token</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_auth_basic</code> \u2014 Method.</p> <pre><code>HTTR.req_auth_basic(req::HTTR.Request, username::AbstractString; password::AbstractString=\"\")::HTTR.Request\n</code></pre> <p>Updates the basic authentication of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>username::AbstractString</code>: The username to be sent in the request.</li> <li><code>password::AbstractString=\"\"</code>: The password to be sent in the request.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_auth_bearer_token</code> \u2014 Method.</p> <pre><code>HTTR.req_auth_bearer_token(req::HTTR.Request, token::AbstractString)::HTTR.Request\n</code></pre> <p>Updates the bearer token authentication of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>token::AbstractString</code>: The bearer token to be sent in the request.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_body_file</code> \u2014 Method.</p> <pre><code>HTTR.req_body_file(req::HTTR.Request, path::AbstractString; type::AbstractString=\"\")::HTTR.Request\n</code></pre> <p>Adds a file body to the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>path::AbstractString</code>: The path to the file to be sent in the request body.</li> <li>`type::AbstractString=\"\": The content type of the request body.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_body_json</code> \u2014 Method.</p> <pre><code>HTTR.req_body_json(req::HTTR.Request, data::Union{AbstractString,AbstractDict}; type::AbstractString=\"\", kwargs...)::HTTR.Request\n</code></pre> <p>Adds a JSON body to the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>data::Union{AbstractString,AbstractDict}</code>: The data to be sent in the request body.</li> <li>`type::AbstractString=\"\": The content type of the request body.</li> <li><code>kwargs</code>: Additional keyword arguments to pass to the <code>JSON3.write</code> function.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_body_raw</code> \u2014 Method.</p> <pre><code>HTTR.req_body_raw(req::HTTR.Request, data::Union{AbstractString,AbstractVector}; type::AbstractString=\"\")::HTTR.Request\n</code></pre> <p>Adds a raw body to the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>data::Union{AbstractString,AbstractVector}</code>: The data to be sent in the request body.</li> <li>`type::AbstractString=\"\": The content type of the request body.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_headers</code> \u2014 Method.</p> <pre><code>HTTR.req_headers(req::HTTR.Request, headers::AbstractVector; redact::Bool=false)::HTTR.Request\n</code></pre> <p>Updates headers of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>headers::AbstractVector</code>: The headers to be sent in the request.</li> <li><code>redact::Bool=false</code>: Whether to redact the headers.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_method</code> \u2014 Method.</p> <pre><code>HTTR.req_method(req::HTTR.Request, method::AbstractString)::HTTR.Request\n</code></pre> <p>Updates the method of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>method::AbstractString</code>: The method to be sent in the request.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_perform</code> \u2014 Method.</p> <pre><code>HTTR.req_perform(req::HTTR.Request)::HTTP.Messages.Response\n</code></pre> <p>Performs the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> </ul> <p>Returns</p> <ul> <li><code>HTTP.Messages.Response</code>: The response object.</li> </ul> <p>source</p> <p># <code>HTTR.req_progress</code> \u2014 Method.</p> <pre><code>HTTR.req_progress(req::HTTR.Request)::HTTR.Request\n</code></pre> <p>Adds a progress bar to the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_retry</code> \u2014 Method.</p> <pre><code>HTTR.req_retry(req::HTTR.Request, max_retries::Int)::HTTR.Request\n</code></pre> <p>Updates the maximum number of retries of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>max_retries::Int</code>: The maximum number of retries.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_timeout</code> \u2014 Method.</p> <pre><code>HTTR.req_timeout(req::HTTR.Request, seconds::Int)::HTTR.Request\n</code></pre> <p>Updates the timeout of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>seconds::Int</code>: The timeout in seconds.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_url</code> \u2014 Method.</p> <pre><code>HTTR.req_url(req::HTTR.Request, url::AbstractString)::HTTR.Request\n</code></pre> <p>Updates the URL of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>url::AbstractString</code>: The URL to be sent in the request.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.req_user_agent</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_verbose</code> \u2014 Method.</p> <pre><code>HTTR.req_verbose(req::HTTR.Request, verbosity::Int)::HTTR.Request\n</code></pre> <p>Updates the verbosity of the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> <li><code>verbosity::Int</code>: The verbosity level.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p># <code>HTTR.request</code> \u2014 Method.</p> <pre><code>HTTR.request(base_url::AbstractString)::HTTR.Request\n</code></pre> <p>Create a new request object.</p> <p>Arguments</p> <ul> <li><code>base_url::AbstractString</code>: The base URL of the request.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: A new request object.</li> </ul> <p>source</p> <p># <code>HTTR.resp_body_html</code> \u2014 Method.</p> <pre><code>HTTR.resp_body_html(resp::HTTP.Messages.Response; check_type::Bool=true, kwargs...)\n</code></pre> <p>Returns the body of the response as an HTML string.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>check_type::Bool=true</code>: Whether to check the content type of the response.</li> <li><code>kwargs</code>: Additional keyword arguments to pass to <code>EzXML.parsehtml</code>.</li> </ul> <p>Returns</p> <ul> <li><code>HTMLDocument</code>: The body of the response as an HTML document.</li> </ul> <p>source</p> <p># <code>HTTR.resp_body_json</code> \u2014 Method.</p> <pre><code>HTTR.resp_body_json(resp::HTTP.Messages.Response; check_type::Bool=true, kwargs...)::Dict\n</code></pre> <p>Returns the body of the response as a JSON object.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>check_type::Bool=true</code>: Whether to check the content type of the response.</li> <li><code>kwargs</code>: Additional keyword arguments to pass to <code>JSON.read</code>.</li> </ul> <p>Returns</p> <ul> <li><code>Dict</code>: The body of the response as a JSON object.</li> </ul> <p>source</p> <p># <code>HTTR.resp_body_raw</code> \u2014 Method.</p> <pre><code>HTTR.resp_body_raw(resp::HTTP.Messages.Response)::Vector{UInt8}\n</code></pre> <p>Returns the raw body of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>Vector{UInt8}</code>: The raw body of the response.</li> </ul> <p>source</p> <p># <code>HTTR.resp_body_string</code> \u2014 Method.</p> <pre><code>HTTR.resp_body_string(resp::HTTP.Messages.Response)::String\n</code></pre> <p>Returns the body of the response as a string.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>String</code>: The body of the response as a string.</li> </ul> <p>source</p> <p># <code>HTTR.resp_body_xml</code> \u2014 Method.</p> <pre><code>HTTR.resp_body_xml(resp::HTTP.Messages.Response; check_type::Bool=true, kwargs...)\n</code></pre> <p>Returns the body of the response as an XML string.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>check_type::Bool=true</code>: Whether to check the content type of the response.</li> <li><code>kwargs</code>: Additional keyword arguments to pass to <code>EzXML.parsexml</code>.</li> </ul> <p>Returns</p> <ul> <li><code>XMLDocument</code>: The body of the response as an XML document.</li> </ul> <p>source</p> <p># <code>HTTR.resp_check_content_type</code> \u2014 Function.</p> <pre><code>HTTR.resp_check_content_type(resp::HTTP.Messages.Response, content_type::AbstractString)\n</code></pre> <p>Checks the content type of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>content_type::AbstractString</code>: The expected content type.</li> </ul> <p>source</p> <p># <code>HTTR.resp_check_status</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_content_type</code> \u2014 Method.</p> <pre><code>HTTR.resp_content_type(resp::HTTP.Messages.Response)\n</code></pre> <p>Returns the content type of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>Union{Nothing,String}</code>: The content type of the response.</li> </ul> <p>source</p> <p># <code>HTTR.resp_date</code> \u2014 Method.</p> <pre><code>HTTR.resp_date(resp::HTTP.Messages.Response)\n</code></pre> <p>Returns the date of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>Union{String,DateTime}</code>: The date of the response. If the date is not available, returns the current time.</li> </ul> <p>source</p> <p># <code>HTTR.resp_encoding</code> \u2014 Method.</p> <pre><code>HTTR.resp_encoding(resp::HTTP.Messages.Response)\n</code></pre> <p>Returns the encoding of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>String</code>: The encoding of the response.</li> </ul> <p>source</p> <p># <code>HTTR.resp_has_body</code> \u2014 Method.</p> <pre><code>HTTR.resp_has_body(resp::HTTP.Messages.Response)::Bool\n</code></pre> <p>Returns whether the response has a body.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> </ul> <p>Returns</p> <ul> <li><code>Bool</code>: Whether the response has a body.</li> </ul> <p>source</p> <p># <code>HTTR.resp_header</code> \u2014 Method.</p> <pre><code>HTTR.resp_header(resp::HTTP.Messages.Response, header::AbstractString)\n</code></pre> <p>Returns the header of the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>header::AbstractString</code>: The name of the header.</li> </ul> <p>Returns</p> <ul> <li><code>Union{Nothing,String}</code>: The value of the header. If the header is not available, returns <code>nothing</code>.</li> </ul> <p>source</p> <p># <code>HTTR.resp_headers</code> \u2014 Function.</p> <p>source</p> <p># <code>HTTR.resp_is_error</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_link_url</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_raw</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_retry_after</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_status</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_status_desc</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_url</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_url_path</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_url_queries</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_url_query</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.secret_has_key</code> \u2014 Method.</p> <pre><code>HTTR.secret_has_key(key::AbstractString)::Bool\n</code></pre> <p>Check if a secret key exists in the environment.</p> <p>Arguments</p> <ul> <li><code>key::AbstractString</code>: The secret key.</li> </ul> <p>Returns</p> <ul> <li><code>Bool</code>: Whether the secret key exists in the environment.</li> </ul> <p>source</p> <p># <code>HTTR.secret_make_key</code> \u2014 Method.</p> <pre><code>HTTR.secret_make_key()::String\n</code></pre> <p>Generate a new secret key that is 16 characters long.</p> <p>source</p> <p># <code>HTTR.url_build</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.url_parse</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.with_verbosity</code> \u2014 Method.</p> <pre><code>HTTR.with_verbosity(req::HTTR.Request)::HTTR.Request\n</code></pre> <p>Adds a verbosity level of 2 to the request.</p> <p>Arguments</p> <ul> <li><code>req::HTTR.Request</code>: The request object.</li> </ul> <p>Returns</p> <ul> <li><code>HTTR.Request</code>: The modified request.</li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":"<p># <code>HTTR.Obfuscated</code> \u2014 Type.</p> <p>source</p> <p># <code>HTTR.curl_translate</code> \u2014 Method.</p> <pre><code>HTTR.curl_translate(cmd, simplify_headers::Bool=true)\n</code></pre> <p>Translate curl commands into HTTR functions.</p> <p>source</p> <p># <code>HTTR.local_mocked_responses</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_client_req_auth</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_client_req_auth_body</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_client_req_auth_header</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_client_req_auth_jwt_sig</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_auth_code</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_bearer_jwt</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_client_credentials</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_device</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_password</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.oauth_flow_refresh</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.obfuscate</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.obfuscated</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_body_form</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_body_json_modify</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_body_multipart</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_cache</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_cookie_preserve</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_dry_run</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_error</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_auth_code</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_bearer_jwt</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_client_credentials</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_device</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_password</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_oauth_refresh</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_options</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_perform_stream</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_proxy</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_template</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_throttle</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_url_path</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_url_path_append</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.req_url_query</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.resp_header_exists</code> \u2014 Method.</p> <pre><code>HTTR.resp_header_exists(resp::HTTP.Messages.Response, header::AbstractString)\n</code></pre> <p>Checks if the header exists in the response.</p> <p>Arguments</p> <ul> <li><code>resp::HTTP.Messages.Response</code>: The response object.</li> <li><code>header::AbstractString</code>: The name of the header.</li> </ul> <p>Returns</p> <ul> <li><code>Bool</code>: Whether the header exists in the response.</li> </ul> <p>source</p> <p># <code>HTTR.secret_decrypt</code> \u2014 Method.</p> <pre><code>HTTR.secret_decrypt(encrypted::AbstractString, key::AbstractString)::String\n</code></pre> <p>source</p> <p># <code>HTTR.secret_decrypt_file</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.secret_encrypt</code> \u2014 Method.</p> <pre><code>HTTR.secret_encrypt(x::AbstractString, key::AbstractString)::String\n</code></pre> <p>source</p> <p># <code>HTTR.secret_encrypt_file</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.secret_read_jld</code> \u2014 Method.</p> <pre><code>HTTR.secret_read_jld(path::AbstractString, key::AbstractString)::String\n</code></pre> <p>Read a secret from a JLD file. <code>secret_write_jld</code> is equivalent to <code>secret_write_rds</code> in R.</p> <p>Arguments</p> <ul> <li><code>path::AbstractString</code>: The path of the JLD file.</li> <li><code>key::AbstractString</code>: The secret key.</li> </ul> <p>Returns</p> <ul> <li><code>String</code>: The secret.</li> </ul> <p>source</p> <p># <code>HTTR.secret_write_jld</code> \u2014 Method.</p> <pre><code>HTTR.secret_write_jld(x::AbstractString, path::AbstractString, key::AbstractString)::String\n</code></pre> <p>Write a secret to a JLD file. <code>secret_read_jld</code> is equivalent to <code>secret_read_rds</code> in R.</p> <p>Arguments</p> <ul> <li><code>x::AbstractString</code>: The secret to write.</li> <li><code>path::AbstractString</code>: The path of the JLD file.</li> <li><code>key::AbstractString</code>: The secret key.</li> </ul> <p>Returns</p> <ul> <li><code>String</code>: The path of the JLD file.</li> </ul> <p>source</p> <p># <code>HTTR.unobfuscate</code> \u2014 Method.</p> <p>source</p> <p># <code>HTTR.with_mocked_responses</code> \u2014 Method.</p> <p>source</p>"},{"location":"examples/generated/UserGuide/get_request_string_response/","title":"Get request string response","text":"<p>This page was generated using Literate.jl.</p>"}]}